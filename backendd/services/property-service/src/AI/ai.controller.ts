// src/controllers/ai.controller.ts
import { Controller, Logger } from '@nestjs/common';
import { MessagePattern, Payload } from '@nestjs/microservices';
import { AIService, GenerateContentDto as ServiceGenerateContentDto, GeneratedContent as ServiceGeneratedContent } from './ai.service';

// Interface pour le contr√¥leur - maintenant compatible avec le service
interface GenerateContentDto {
  // Basic property info
  propertyType: string;
  location: string;
  title?: string;
  description?: string;
  
  // Property details
  size?: number;
  floorNumber?: number;
  lotSize?: number;
  rooms?: number;
  bedrooms?: number;
  bathrooms?: number;
  beds_Number?: number;
  numberOfBalconies?: number;
  maxGuest?: number;
  minNight?: number;
  maxNight?: number;
  
  // Property spaces
  apartmentSpaces?: Array<{
    space_id: string;
    type: string;
    area: string;
    photos: File[];
  }>;
  
  // Location details
  latitude?: number;
  longitude?: number;
  address?: string;
  city?: string;
  country?: string;
  
  // Amenities - accepte les deux formats
  amenities?: {
    WiFi?: boolean;
    Kitchen?: boolean;
    Washer?: boolean;
    Dryer?: boolean;
    Free_parking?: boolean;
    Air_conditioning?: boolean;
    Heating?: boolean;
    TV?: boolean;
    Breakfast?: boolean;
    Laptop_friendly_workspace?: boolean;
    Crib?: boolean;
    Hair_dryer?: boolean;
    Iron?: boolean;
    Essentials?: boolean;
    Smoke_alarm?: boolean;
    Carbon_monoxide_alarm?: boolean;
    Fire_extinguisher?: boolean;
    First_aid_kit?: boolean;
    Lock_on_bedroom_door?: boolean;
    Hangers?: boolean;
    Shampoo?: boolean;
    Garden_or_backyard?: boolean;
    Patio_or_balcony?: boolean;
    BBQ_grill?: boolean;
  } | string[]; // Accepte aussi un array de strings pour compatibilit√©
  
  // Policies
  policies?: {
    smoking?: boolean;
    pets?: boolean;
    parties_or_events?: boolean;
    guests_allowed?: boolean;
    check_in_start?: string;
    check_in_end?: string;
    check_out_start?: string;
    check_out_end?: string;
    quiet_hours_start?: string;
    quiet_hours_end?: string;
    cleaning_maintenance?: string;
    cancellation_policy?: string;
  };
  
  // Payment methods
  paymentMethods?: string[];
  
  // Contact info
  phone?: string;
  email?: string;
  website?: string;
  
  // Generation preferences
  userPrompt: string;
  targetAudience?: string;
  tone?: string;
  language?: string;
  features?: string[];
  
  // Champs additionnels pour le microservice
  firebaseUid?: string;
  propertyId?: string;
  isRegeneration?: boolean;
  requestTimestamp?: string;
}

// Interface de retour simplifi√©e pour le microservice
interface GeneratedContentResponse {
  title: string;
  description: string;
  keywords: string[];
  improvements?: string[];
  seoTips?: string[];
  marketingHighlights?: string[];
}

@Controller()
export class AIController {
  private readonly logger = new Logger(AIController.name);

  constructor(private readonly aiService: AIService) {}

  @MessagePattern({ cmd: 'generate_optimized_content' })
  async generateOptimizedContent(@Payload() data: GenerateContentDto): Promise<{
    statusCode: number;
    data?: GeneratedContentResponse;
    error?: string;
  }> {
    try {
      this.logger.log('ü§ñ AI Microservice: Optimized content generation requested');
      this.logger.debug('Received data keys:', Object.keys(data));

      // Validation des champs requis
      if (!data.propertyType || !data.location || !data.userPrompt) {
        this.logger.error('‚ùå Missing required fields');
        return {
          statusCode: 400,
          error: 'Missing required fields: propertyType, location, and userPrompt are required'
        };
      }

      // Transformation des donn√©es pour le service (maintenant plus directe)
      const serviceData = this.transformToServiceFormat(data);
      
      this.logger.debug('Transformed data for service:', Object.keys(serviceData));
      
      // Appel du service AI
      const aiResult = await this.aiService.generateOptimizedContent(serviceData);
      
      // Transformation du r√©sultat pour correspondre √† l'interface de r√©ponse
      const transformedResult: GeneratedContentResponse = {
        title: aiResult.title,
        description: aiResult.description,
        keywords: aiResult.suggestions?.keywords || [],
        improvements: aiResult.suggestions?.improvements || [],
        seoTips: aiResult.suggestions?.seoTips || [],
        marketingHighlights: aiResult.suggestions?.marketingHighlights || []
      };
      
      this.logger.log('‚úÖ AI Content generated successfully');
      this.logger.debug('Generated content preview:', {
        titleLength: transformedResult.title.length,
        descriptionLength: transformedResult.description.length,
        keywordsCount: transformedResult.keywords.length
      });
      
      return {
        statusCode: 200,
        data: transformedResult
      };

    } catch (error: any) {
      this.logger.error('‚ùå Error during AI content generation:', {
        message: error.message,
        stack: error.stack?.substring(0, 500)
      });
      
      return {
        statusCode: error.status || 500,
        error: error.message || 'Internal server error during content generation'
      };
    }
  }

  @MessagePattern({ cmd: 'validate_ai_config' })
  async validateAIConfig(@Payload() data: { firebaseUid?: string }): Promise<{ 
    isValid: boolean; 
    message: string;
    provider?: string;
  }> {
    try {
      this.logger.log('üîç AI Microservice: Validating AI configuration');
      
      const isValid = await this.aiService.validateApiKey();
      
      return {
        isValid,
        provider: 'Google Gemini',
        message: isValid 
          ? 'Gemini AI configuration is valid and ready' 
          : 'Gemini AI configuration is invalid - please check your API key'
      };
    } catch (error: any) {
      this.logger.error('‚ùå AI validation error:', error.message);
      return {
        isValid: false,
        provider: 'Google Gemini',
        message: 'Error occurred during AI configuration validation'
      };
    }
  }

  @MessagePattern({ cmd: 'get_content_suggestions' })
  async getContentSuggestions(@Payload() data: { 
    propertyType: string; 
    location: string;
    language?: string;
  }): Promise<{
    statusCode: number;
    data?: string[];
    error?: string;
  }> {
    try {
      this.logger.log('üí° AI Microservice: Content suggestions requested');
      this.logger.debug('Request data:', { 
        propertyType: data.propertyType, 
        location: data.location,
        language: data.language 
      });
      
      if (!data.propertyType || !data.location) {
        return {
          statusCode: 400,
          error: 'Property type and location are required'
        };
      }

      const suggestions = this.generateSuggestionsByPropertyType(
        data.propertyType, 
        data.location, 
        data.language
      );
      
      this.logger.log(`‚úÖ Generated ${suggestions.length} suggestions`);

      return {
        statusCode: 200,
        data: suggestions
      };

    } catch (error: any) {
      this.logger.error('‚ùå Error generating suggestions:', error.message);
      return {
        statusCode: 500,
        data: ['Unable to load suggestions at the moment'],
        error: error.message || 'Error generating content suggestions'
      };
    }
  }

  @MessagePattern({ cmd: 'get_ai_generation_history' })
  async getAIGenerationHistory(@Payload() data: { 
    firebaseUid: string; 
    limit?: number;
    propertyId?: string;
  }): Promise<{
    statusCode: number;
    data?: any[];
    error?: string;
    meta?: { total: number; limit: number; };
  }> {
    try {
      this.logger.log(`üìú AI Microservice: Retrieving AI generation history for user: ${data.firebaseUid}`);
      
      // TODO: Implement actual database storage/retrieval
      // Pour l'instant, retourne un historique vide
      return {
        statusCode: 200,
        data: [],
        meta: {
          total: 0,
          limit: data.limit || 10
        }
      };

    } catch (error: any) {
      this.logger.error('‚ùå Error retrieving AI history:', error.message);
      return {
        statusCode: 500,
        error: 'Error retrieving AI generation history'
      };
    }
  }

  @MessagePattern({ cmd: 'get_ai_service_status' })
  async getAIServiceStatus(): Promise<{
    statusCode: number;
    data?: {
      status: string;
      provider: string;
      isConfigured: boolean;
      lastCheck?: string;
    };
    error?: string;
  }> {
    try {
      this.logger.log('üìä AI Microservice: Status check requested');
      
      const isConfigured = await this.aiService.validateApiKey();
      
      return {
        statusCode: 200,
        data: {
          status: isConfigured ? 'operational' : 'configuration_error',
          provider: 'Google Gemini',
          isConfigured,
          lastCheck: new Date().toISOString()
        }
      };
    } catch (error: any) {
      this.logger.error('‚ùå Error checking AI service status:', error.message);
      return {
        statusCode: 500,
        error: 'Error checking AI service status'
      };
    }
  }

  /**
   * Transforme les donn√©es du contr√¥leur vers le format attendu par le service
   */
  private transformToServiceFormat(controllerData: GenerateContentDto): ServiceGenerateContentDto {
    // Gestion des amenities - conversion array vers objet si n√©cessaire
    let amenitiesObject: ServiceGenerateContentDto['amenities'] = undefined;
    
    if (controllerData.amenities) {
      if (Array.isArray(controllerData.amenities)) {
        // Conversion array vers objet
        amenitiesObject = {};
        controllerData.amenities.forEach(amenity => {
          const amenityKey = amenity.replace(/\s+/g, '_') as keyof NonNullable<ServiceGenerateContentDto['amenities']>;
          if (amenitiesObject) {
            (amenitiesObject as any)[amenityKey] = true;
          }
        });
      } else {
        // D√©j√† un objet, utilise tel quel
        amenitiesObject = controllerData.amenities as ServiceGenerateContentDto['amenities'];
      }
    }

    // Construction de l'objet de service avec tous les champs
    const serviceData: ServiceGenerateContentDto = {
      // Champs obligatoires
      propertyType: controllerData.propertyType,
      location: controllerData.location,
      userPrompt: controllerData.userPrompt,
      
      // Champs optionnels - copie directe
      title: controllerData.title,
      description: controllerData.description,
      size: controllerData.size,
      floorNumber: controllerData.floorNumber,
      lotSize: controllerData.lotSize,
      rooms: controllerData.rooms,
      bedrooms: controllerData.bedrooms,
      bathrooms: controllerData.bathrooms,
      beds_Number: controllerData.beds_Number,
      numberOfBalconies: controllerData.numberOfBalconies,
      maxGuest: controllerData.maxGuest,
      minNight: controllerData.minNight,
      maxNight: controllerData.maxNight,
      apartmentSpaces: controllerData.apartmentSpaces,
      latitude: controllerData.latitude,
      longitude: controllerData.longitude,
      address: controllerData.address,
      city: controllerData.city,
      country: controllerData.country,
      amenities: amenitiesObject,
      policies: controllerData.policies,
      paymentMethods: controllerData.paymentMethods,
      phone: controllerData.phone,
      email: controllerData.email,
      website: controllerData.website,
      targetAudience: controllerData.targetAudience,
      tone: controllerData.tone,
      language: controllerData.language,
      features: controllerData.features
    };

    // Supprime les propri√©t√©s undefined pour √©viter la pollution
    Object.keys(serviceData).forEach(key => {
      if ((serviceData as any)[key] === undefined) {
        delete (serviceData as any)[key];
      }
    });

    return serviceData;
  }

  /**
   * G√©n√®re des suggestions personnalis√©es par type de propri√©t√© et localisation
   */
  private generateSuggestionsByPropertyType(
    propertyType: string, 
    location: string, 
    language?: string
  ): string[] {
    const suggestions: string[] = [];
    const type = propertyType?.toLowerCase();
    const isArabic = language === 'ar';
    const isFrench = language === 'fr';
    
    // Suggestions sp√©cifiques par type de propri√©t√©
    switch (type) {
      case 'villa':
        if (isArabic) {
          suggestions.push(
            'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖÿ≥ÿßÿ≠ÿßÿ™ ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ÿßŸÑŸàÿßÿ≥ÿπÿ© ŸàÿßŸÑŸÖÿ≥ÿ®ÿ≠ ÿßŸÑÿÆÿßÿµ',
            'ÿ£ŸÉÿØ ÿπŸÑŸâ ÿßŸÑÿÆÿµŸàÿµŸäÿ© ŸàÿßŸÑÿ±ŸÅÿßŸáŸäÿ©',
            'ÿßÿ∞ŸÉÿ± ÿßŸÑÿ≠ÿØŸäŸÇÿ© ŸàŸÖŸÜÿßÿ∑ŸÇ ÿ™ŸÜÿßŸàŸÑ ÿßŸÑÿ∑ÿπÿßŸÖ ŸÅŸä ÿßŸÑŸáŸàÿßÿ° ÿßŸÑÿ∑ŸÑŸÇ'
          );
        } else if (isFrench) {
          suggestions.push(
            'Mettez en avant les espaces ext√©rieurs spacieux et la piscine priv√©e',
            'Insistez sur l\'intimit√© et les √©quipements de luxe',
            'Mentionnez le jardin et les espaces de restauration en plein air'
          );
        } else {
          suggestions.push(
            'Highlight the spacious outdoor areas and private pool',
            'Emphasize privacy and luxury amenities',
            'Mention the garden, landscaping, and outdoor dining areas',
            'Describe parking facilities and security features'
          );
        }
        break;
        
      case 'apartment':
      case 'appartement':
        if (isArabic) {
          suggestions.push(
            'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸàŸÇÿπ ÿßŸÑŸÖÿ±ŸÉÿ≤Ÿä ÿßŸÑŸÖÿ±Ÿäÿ≠',
            'ÿßÿ∞ŸÉÿ± ÿßŸÑŸÇÿ±ÿ® ŸÖŸÜ Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑŸÜŸÇŸÑ ÿßŸÑÿπÿßŸÖ',
            'ÿ£ŸÉÿØ ÿπŸÑŸâ Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ±ÿßÿ≠ÿ© ÿßŸÑÿ≠ÿØŸäÿ´ÿ©'
          );
        } else if (isFrench) {
          suggestions.push(
            'Mettez en avant l\'emplacement central pratique',
            'Mentionnez la proximit√© des transports en commun',
            'Insistez sur les √©quipements modernes'
          );
        } else {
          suggestions.push(
            'Highlight the convenient central location',
            'Mention proximity to public transportation',
            'Emphasize modern amenities and building facilities'
          );
        }
        break;
        
      case 'hotel':
        if (isArabic) {
          suggestions.push(
            'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿÆÿØŸÖÿßÿ™ ÿßŸÑÿ∂ŸäÿßŸÅÿ© ÿßŸÑŸÖŸáŸÜŸäÿ©',
            'ÿßÿ∞ŸÉÿ± ÿßŸÑÿ•ŸÅÿ∑ÿßÿ± ÿßŸÑŸÖÿ¨ÿßŸÜŸä ŸàÿßŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸäŸàŸÖŸä',
            'ÿ£ŸÉÿØ ÿπŸÑŸâ ÿÆÿØŸÖÿ© ÿßŸÑÿßÿ≥ÿ™ŸÇÿ®ÿßŸÑ ÿπŸÑŸâ ŸÖÿØÿßÿ± 24 ÿ≥ÿßÿπÿ©'
          );
        } else if (isFrench) {
          suggestions.push(
            'Mettez en avant les services d\'accueil professionnels',
            'Mentionnez le petit-d√©jeuner gratuit et le service de m√©nage quotidien',
            'Insistez sur la r√©ception 24h/24'
          );
        } else {
          suggestions.push(
            'Highlight professional hospitality services',
            'Mention complimentary breakfast and daily housekeeping',
            'Emphasize 24/7 front desk and concierge services'
          );
        }
        break;
        
      case 'house':
      case 'maison':
        if (isArabic) {
          suggestions.push(
            'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÑŸÑÿπÿßÿ¶ŸÑÿßÿ™ ŸàÿßŸÑŸÖÿ≥ÿßÿ≠ÿ©',
            'ÿßÿ∞ŸÉÿ± ÿßŸÑÿ≠Ÿä ÿßŸÑÿ¢ŸÖŸÜ ŸàÿßŸÑÿ¥ÿπŸàÿ± ÿ®ÿßŸÑŸÖÿ¨ÿ™ŸÖÿπ',
            'ÿ£ŸÉÿØ ÿπŸÑŸâ ŸÖÿ≥ÿßÿ≠ÿßÿ™ ÿßŸÑŸÖÿπŸäÿ¥ÿ© ÿßŸÑÿØÿßÿÆŸÑŸäÿ© ŸàÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ©'
          );
        } else if (isFrench) {
          suggestions.push(
            'Mettez en avant les caract√©ristiques adapt√©es aux familles',
            'Mentionnez le quartier s√ªr et l\'esprit communautaire',
            'Insistez sur les espaces de vie int√©rieurs et ext√©rieurs'
          );
        } else {
          suggestions.push(
            'Highlight family-friendly features and space',
            'Mention the safe neighborhood and community feel',
            'Emphasize indoor and outdoor living spaces'
          );
        }
        break;
        
      default:
        if (isArabic) {
          suggestions.push(
            'ÿµŸÅ ÿßŸÑÿ∑ÿßÿ®ÿπ ŸàÿßŸÑÿ¨Ÿà ÿßŸÑŸÅÿ±ŸäÿØ',
            'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ Ÿàÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ±ÿßÿ≠ÿ© ŸàÿßŸÑŸÖŸäÿ≤ÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©',
            'ÿßÿ∞ŸÉÿ± ŸÖÿß Ÿäÿ¨ÿπŸÑ Ÿáÿ∞ÿß ÿßŸÑÿπŸÇÿßÿ± ŸÖŸÖŸäÿ≤ÿßŸã'
          );
        } else if (isFrench) {
          suggestions.push(
            'D√©crivez le caract√®re unique et l\'atmosph√®re',
            'Mettez en avant les √©quipements et caract√©ristiques principales',
            'Mentionnez ce qui rend cette propri√©t√© sp√©ciale'
          );
        } else {
          suggestions.push(
            'Describe the unique character and atmosphere',
            'Highlight the main amenities and features',
            'Mention what makes this property special'
          );
        }
    }

    // Suggestions sp√©cifiques √† la localisation tunisienne
    const locationLower = location?.toLowerCase() || '';
    
    if (locationLower.includes('tunisia') || locationLower.includes('tunisie') || locationLower.includes('ÿ™ŸàŸÜÿ≥')) {
      if (isArabic) {
        suggestions.push(
          'ÿßÿ∞ŸÉÿ± ÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ™ŸàŸÜÿ≥Ÿäÿ© ÿßŸÑÿ£ÿµŸäŸÑÿ©',
          'ÿßÿ±ŸÉÿ≤ ÿπŸÑŸâ ÿßŸÑŸÇÿ±ÿ® ŸÖŸÜ ÿ¥Ÿàÿßÿ∑ÿ¶ ÿßŸÑÿ®ÿ≠ÿ± ÿßŸÑŸÖÿ™Ÿàÿ≥ÿ∑',
          'ÿµŸÅ ÿßŸÑŸàÿµŸàŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿ≥ŸàÿßŸÇ ÿßŸÑŸÖÿ≠ŸÑŸäÿ© ŸàÿßŸÑŸÖŸàÿßŸÇÿπ ÿßŸÑÿ´ŸÇÿßŸÅŸäÿ©'
        );
      } else if (isFrench) {
        suggestions.push(
          'Mentionnez l\'exp√©rience tunisienne authentique',
          'Mettez en avant la proximit√© des plages m√©diterran√©ennes',
          'D√©crivez l\'acc√®s aux march√©s locaux et sites culturels'
        );
      } else {
        suggestions.push(
          'Mention the authentic Tunisian experience',
          'Highlight proximity to Mediterranean beaches',
          'Describe access to local markets and cultural sites'
        );
      }
    }

    // Suggestions g√©n√©rales SEO et marketing
    if (isArabic) {
      suggestions.push(
        'ÿßÿ≥ÿ™ÿÆÿØŸÖ ŸÉŸÑŸÖÿßÿ™ ŸÖŸÅÿ™ÿßÿ≠Ÿäÿ© ÿÆÿßÿµÿ© ÿ®ÿßŸÑŸÖŸàŸÇÿπ',
        'ÿßÿ∞ŸÉÿ± ÿßŸÑŸÖÿπÿßŸÑŸÖ ÿßŸÑÿ≥Ÿäÿßÿ≠Ÿäÿ© ÿßŸÑŸÇÿ±Ÿäÿ®ÿ©',
        'ÿµŸÅ ŸÜŸàÿπ ÿßŸÑÿ™ÿ¨ÿ±ÿ®ÿ© ÿßŸÑÿ™Ÿä ŸäŸÖŸÉŸÜ ŸÑŸÑÿ∂ŸäŸàŸÅ ÿ™ŸàŸÇÿπŸáÿß'
      );
    } else if (isFrench) {
      suggestions.push(
        'Utilisez des mots-cl√©s sp√©cifiques √† la localisation',
        'Mentionnez les attractions et points d\'int√©r√™t √† proximit√©',
        'D√©crivez le type d\'exp√©rience que les clients peuvent attendre'
      );
    } else {
      suggestions.push(
        'Use location-specific keywords throughout the description',
        'Mention nearby attractions and points of interest',
        'Describe the type of experience guests can expect',
        'Include details about accessibility and transportation'
      );
    }

    return suggestions.slice(0, 12); // Limite √† 12 suggestions maximum
  }
}